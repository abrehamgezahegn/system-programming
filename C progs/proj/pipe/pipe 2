–––––––––––––––––––––––––––––––––––––––––––––––––––––––– pipes/pipe_sync.c
#include "curr_time.h"
#include "tlpi_hdr.h"
int
main(int argc, char *argv[])
{
int pfd[2];
int j, dummy;
/* Declaration of currTime() */
/* Process synchronization pipe */
Pipes and F I FOs
897if (argc < 2 || strcmp(argv[1], "--help") == 0)
usageErr("%s sleep-time...\n", argv[0]);
setbuf(stdout, NULL);
printf("%s
q
/* Make stdout unbuffered, since we
terminate child with _exit() */
Parent started\n", currTime("%T"));
if (pipe(pfd) == -1)
errExit("pipe");
for (j = 1; j < argc; j++) {
switch (fork()) {
case -1:
errExit("fork %d", j);
w
case 0: /* Child */
if (close(pfd[0]) == -1)
errExit("close");
/* Read end is unused */
/* Child does some work, and lets parent know it's done */
sleep(getInt(argv[j], GN_NONNEG, "sleep-time"));
/* Simulate processing */
printf("%s Child %d (PID=%ld) closing pipe\n",
currTime("%T"), j, (long) getpid());
if (close(pfd[1]) == -1)
errExit("close");
e
/* Child now carries on to do other things... */
_exit(EXIT_SUCCESS);
default: /* Parent loops to create next child */
break;
}
}
/* Parent comes here; close write end of pipe so we can see EOF */
r
if (close(pfd[1]) == -1)
errExit("close");
/* Write end is unused */
/* Parent may do other work, then synchronizes with children */
t
if (read(pfd[0], &dummy, 1) != 0)
fatal("parent didn't get EOF");
printf("%s Parent ready to go\n", currTime("%T"));
/* Parent can now carry on to do other things... */
exit(EXIT_SUCCESS);
}
